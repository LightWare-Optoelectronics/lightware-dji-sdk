"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[487],{6074:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var t=i(4848),a=i(8453);const s={title:"Software",sidebar_position:5},o=void 0,r={id:"landing-moving-platform/software",title:"Software",description:"Payload SDK & Raspberry Pi",source:"@site/docs/landing-moving-platform/software.md",sourceDirName:"landing-moving-platform",slug:"/landing-moving-platform/software",permalink:"/lightware-dji-sdk/landing-moving-platform/software",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Software",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Hardware",permalink:"/lightware-dji-sdk/landing-moving-platform/hardware"},next:{title:"Conclusion",permalink:"/lightware-dji-sdk/landing-moving-platform/conclusion"}},c={},l=[{value:"Payload SDK &amp; Raspberry Pi",id:"payload-sdk--raspberry-pi",level:3},{value:"Project code",id:"project-code",level:3},{value:"Connecting to the Aircraft",id:"connecting-to-the-aircraft",level:4},{value:"Connection to the LW20/C",id:"connection-to-the-lw20c",level:4},{value:"Plane detection logic",id:"plane-detection-logic",level:4},{value:"Landing Routine",id:"landing-routine",level:4},{value:"Additional code",id:"additional-code",level:3},{value:"Maintaining the application active until triggered from the ground",id:"maintaining-the-application-active-until-triggered-from-the-ground",level:4},{value:"Following the landing target",id:"following-the-landing-target",level:4},{value:"Landing risk validation",id:"landing-risk-validation",level:4}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"payload-sdk--raspberry-pi",children:"Payload SDK & Raspberry Pi"}),"\n",(0,t.jsxs)(n.p,{children:["DJI provides thorough instructions for setting up the Raspberry Pi with the Payload SDK. Follow the ",(0,t.jsx)(n.a,{href:"https://developer.dji.com/doc/payload-sdk-tutorial/en/quick-start/quick-guide/raspberry-pi.html#software-environment-setup",children:"setup\nguide"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Run the sample code to confirm the installation before proceeding to the next steps."}),"\n",(0,t.jsx)(n.p,{children:"Ensure the Raspberry Pi is connected to the local Wi-Fi network if available, and for ease of use, enable SSH access."}),"\n",(0,t.jsx)(n.p,{children:'In the Raspberry Pi Configuration menu (accessible from the top left),switch on the "I2C" interface.'}),"\n",(0,t.jsx)(n.p,{children:"If not already installed, install I2C tools by issuing the following\ncommand in the terminal window:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"sudo apt-get install i2c-tools\n"})}),"\n",(0,t.jsx)(n.p,{children:"Once installed, run the following command to verify that the sensors are correctly detected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"i2cdetect -y 1\n"})}),"\n",(0,t.jsx)(n.p,{children:"A table displaying the I2C addresses will be produced. Confirm that each\nLiDAR sensor is recognized by the system."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:                         -- -- -- -- -- -- -- -- \n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n60: -- -- -- -- -- -- 66 67 68 69 -- -- -- -- -- -- \n70: -- -- -- -- -- -- -- --  \n"})}),"\n",(0,t.jsx)(n.p,{children:"You are now ready to dive into the code."}),"\n",(0,t.jsx)(n.h3,{id:"project-code",children:"Project code"}),"\n",(0,t.jsxs)(n.p,{children:["All the code is available in a GitHub repository ",(0,t.jsx)(n.a,{href:"https://github.com/LightWare-Optoelectronics/lightware-dji-sdk/tree/main/psdk-sample/landing-moving-platform",children:"here"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The code is structured by creating several classes to abstract the sensor functions, manage the array of sensors, and handle the vehicle interaction."}),"\n",(0,t.jsxs)(n.p,{children:["For the vehicle and to remain true to the content set by DJI, the same ",(0,t.jsx)(n.code,{children:"Application"})," class is used from the DJI ",(0,t.jsx)(n.a,{href:"https://github.com/dji-sdk/Payload-SDK/blob/master/samples/sample_c%2B%2B/platform/linux/nvidia_jetson/application/application.hpp",children:"sample code"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"connecting-to-the-aircraft",children:"Connecting to the Aircraft"}),"\n",(0,t.jsx)(n.p,{children:"The Payload SDK is used to simplify the connection to the aircraft. Once the hardware setup is complete, the code handles the interaction as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Application *vehicle = NULL;\n\nint main(int argc, char **argv) {\n    // Create the vehicle instance to connect\n    // We are reusing the Application object from DJI's sample for clarity only.\n    vehicle = new Application(argc, argv);\n"})}),"\n",(0,t.jsx)(n.p,{children:"From this point on, the vehicle object can be used to abstract vehicle\nfunctions."}),"\n",(0,t.jsx)(n.admonition,{title:"Note",type:"info",children:(0,t.jsx)(n.p,{children:"The Payload SDK provides functions that are accessible in the global space. However, structuring these functions using objects is a cleaner and more organized approach."})}),"\n",(0,t.jsx)(n.h4,{id:"connection-to-the-lw20c",children:"Connection to the LW20/C"}),"\n",(0,t.jsxs)(n.p,{children:["Two objects will be created to facilitate the connection to the LightWare LiDAR sensors: ",(0,t.jsx)(n.code,{children:"LW20/C"})," and ",(0,t.jsx)(n.code,{children:"SensorArray"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"LW20"})," is used to abstract a single sensor. This includes all controls and reads."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SensorArray"})," is specific to this project and abstracts the four sensors in their physical configuration."]}),"\n",(0,t.jsx)(n.admonition,{title:"Note",type:"info",children:(0,t.jsx)(n.p,{children:"These abstractions can be further expanded if needed. These classes are the ideal place to encapsulate additional functionality as the project evolves."})}),"\n",(0,t.jsx)(n.p,{children:"Start by including all the necessary headers, and then proceed with the class declarations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"//\n// Created by LightWare.\n// LW20/c Interface\n//\n\n#pragma once\n\n#include <iostream>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <atomic>\n#include <thread>\n#include <sys/ioctl.h>\n#include <asm/ioctl.h>\n\n#include <fcntl.h>\n#include <string.h>\n\nclass LW20 {\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Thereafter, an ",(0,t.jsx)(n.code,{children:"ioctl"})," configuration macro is defined. This is necessary due to the project using a Raspberry Pi 5 and the wiringPi, which handles these variations, isn't available."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#define I2C_SLAVE\t0x0703\n"})}),"\n",(0,t.jsx)(n.p,{children:"The public interface which manages the life cycle of the abstraction and protected access to private information is implemented as follow:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'\npublic:\n    LW20() {\n\n    }\n\n    ~LW20() {\n        this->disconnect();\n    }\n\n    void connect(int i2cAddress) {\n        _deviceAddress = i2cAddress;\n\n        const char *device = "/dev/i2c-1"; // This may change, wiringPi has a good discovery for this, but it\'s not available yet on pi5.\n        _fd = open (device, O_RDWR);\n\n        if (_fd == -1) {\n            std::cerr << "I2C Bus file could not be opened" << std::endl;\n        } else {\n            std::cerr << "I2C Bus opened on FD: " << _fd << std::endl;\n\n            if (ioctl (_fd, I2C_SLAVE, i2cAddress) < 0) {\n                std::cerr << "Unable to select I2C device: " << strerror(errno) << std::endl;\n            } else {\n                _threadRunning.store(true, std::memory_order_relaxed);\n                _runningThread = std::thread(&LW20::loop, this);\n            }\n        }\n    }\n\n    void disconnect() {\n        _threadRunning.store(false, std::memory_order_relaxed);\n        close(_fd);\n    }\n\n    int latestDistance() {\n        return this->_latestDistance.load(std::memory_order_relaxed);\n    }\n'})}),"\n",(0,t.jsx)(n.p,{children:"The private implementation which covers the internal loop running in a background thread to read the data from the sensor and the protected variables are implemented as follow:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'\nprivate:\n    std::atomic<bool> _threadRunning{false};\n    std::thread _runningThread;\n\n    int _deviceAddress = 0x66; // default factory value\n    int _fd;\n\n    std::atomic<int> _latestDistance{0}; // in cm\n\n    // Loop running in background thread.\n    void loop() {\n        while (_threadRunning.load(std::memory_order_relaxed))  {\n            unsigned char byte[2];\n            int res = read(_fd, byte, 2);\n\n            if (res == -1) {\n                std::cout << "I2C Device with address " << _deviceAddress << " was not available" << std::endl;\n            } else {\n                int distanceRead = (byte[0] << 8) | byte[1];\n                std::cout << "[" << _deviceAddress << "] Distance: " << distanceRead << "cm" << std::endl;\n\n                _latestDistance.store(distanceRead, std::memory_order_relaxed);\n            }\n\n            usleep(250);\n        }\n    }\n};\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"Note",type:"info",children:(0,t.jsx)(n.p,{children:"In the way this class is set, the address is defined during the connect function. Alternatively, the address could be assigned during object allocation and create a parameter-less connect function."})}),"\n",(0,t.jsxs)(n.p,{children:["With the single sensor implementation in place, the next step is to create the ",(0,t.jsx)(n.code,{children:"SensorArray"})," object."]}),"\n",(0,t.jsx)(n.p,{children:"This object is a convenience abstraction that streamlines the main business logic, keeping it clean and organized behind well-defined classes. This approach simplifies interaction with the multiple sensors by handling their configuration in one central object."}),"\n",(0,t.jsx)(n.p,{children:"Start by including the necessary header files and proceed with the class declaration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'//\n// Created by LightWare.\n// Software representation of the LW20/c quad sensor array for platform detection\n//\n\n#pragma once\n\n#include "LW20.h"\n#include <limits>\n\nclass SensorArray {\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"The public interface handles the life cycle of the sensors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"public:\n    SensorArray() {\n        this->_sensor1 = new LW20();\n        this->_sensor2 = new LW20();\n        this->_sensor3 = new LW20();\n        this->_sensor4 = new LW20();\n    }\n\n    ~SensorArray() {\n        delete this->_sensor1;\n        delete this->_sensor2;\n        delete this->_sensor3;\n        delete this->_sensor4;\n    }\n\n    // Connects the entire array and start receiving distances\n    void connect() {\n        this->_sensor1->connect(0x66);\n        this->_sensor2->connect(0x67);\n        this->_sensor3->connect(0x68);\n        this->_sensor4->connect(0x69);\n    }\n\n    // Average distance in cm\n    int averageDistance() {\n        int sensor1LastRead = this->_sensor1->latestDistance();\n        int sensor2LastRead = this->_sensor2->latestDistance();\n        int sensor3LastRead = this->_sensor3->latestDistance();\n        int sensor4LastRead = this->_sensor4->latestDistance();\n\n        return (sensor1LastRead + sensor2LastRead + sensor3LastRead + sensor4LastRead)/4;\n    }\n\n    // Return the maximum differences between the closest and the furthest away hit\n    int maxDelta() {\n        int sensor1LastRead = this->_sensor1->latestDistance();\n        int sensor2LastRead = this->_sensor2->latestDistance();\n        int sensor3LastRead = this->_sensor3->latestDistance();\n        int sensor4LastRead = this->_sensor4->latestDistance();\n\n        int distances[4] = {sensor1LastRead, sensor2LastRead, sensor3LastRead, sensor4LastRead};\n        int lowest = std::numeric_limits<int>::max();\n        int highest = std::numeric_limits<int>::min();\n\n        for(int i = 0; i < size; ++i) {\n            if(distances[i] < lowest) {\n                lowest = distances[i];\n            }\n            if(distances[i] > highest) {\n                highest = distances[i];\n            }\n        }\n\n        return highest - lowest;\n    }\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Private interfaces aren't doing much except holding onto the sensor pointers."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"private:\n    LW20 *_sensor1;\n    LW20 *_sensor2;\n    LW20 *_sensor3;\n    LW20 *_sensor4;\n\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now that we have an abstraction for the vehicle and the sensor array, it's time to tie it all up together."}),"\n",(0,t.jsx)(n.h4,{id:"plane-detection-logic",children:"Plane detection logic"}),"\n",(0,t.jsx)(n.p,{children:"The project follows a straightforward approach to utilizing the sensors for plane detection. This basic implementation serves as a starting point, leaving plenty of room for further enhancements to build a more\nresilient and production-ready solution."}),"\n",(0,t.jsx)(n.p,{children:"After covering this simple logic, we'll discuss potential next steps to refine and expand upon the solution."}),"\n",(0,t.jsx)(n.p,{children:"Within the main function of the main.cpp, the abstraction for the sensor array and connection is created before the abstraction for the vehicle."}),"\n",(0,t.jsx)(n.p,{children:"Once both abstractions are set up, the landing logic can be applied."}),"\n",(0,t.jsx)(n.p,{children:"The code continuously loops, checking the sensor data until the landing condition is satisfied."}),"\n",(0,t.jsx)(n.p,{children:"When the condition is met, the loop exits, and the landing sequence is initiated."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int main(int argc, char **argv) {\n    // Create the vehicle instance to connect\n    // We are reusing the Application object from DJI's sample for clarity only.\n    vehicle = new Application(argc, argv);\n\n    sensorArray = new SensorArray();\n    sensorArray->connect();\n\n    // Check loop\n    bool checkingToLand = true;\n    int flatEnough = 10; // in cm; 10cm -> ~15\xb0 plane\n\n    while (checkingToLand) {\n        int maxDelta = sensorArray->maxDelta();\n\n        // Condition to determine a landing opportunity.\n        if (maxDelta <= flatEnough && maxDelta > 0) {\n            checkingToLand = false;\n            break;\n        }\n    }\n"})}),"\n",(0,t.jsx)(n.h4,{id:"landing-routine",children:"Landing Routine"}),"\n",(0,t.jsx)(n.p,{children:"Landing is a single function call behind an abstraction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'    if (!checkingToLand) {\n        // We exited the loop flagging we aren\'t checking to land, so we are landing.\n        std::cout << "Landing..." << std::endl;\n\n        vehicle->land();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"additional-code",children:"Additional code"}),"\n",(0,t.jsx)(n.h4,{id:"maintaining-the-application-active-until-triggered-from-the-ground",children:"Maintaining the application active until triggered from the ground"}),"\n",(0,t.jsx)(n.p,{children:'The code enters the "checking to land" logic immediately upon launch. This could be impractical in real-world applications. Ideally, the application should activate with the vehicle\'s lifecycle and only begin its landing logic when triggered by a pilot, operator, or an automated system.'}),"\n",(0,t.jsx)(n.p,{children:'To achieve this, consider the use of MOP (MobileSDK to PayloadSDK communication), also referred to as SDK Interconnection or Pipeline in DJI\'s MobileSDK. MOP allows a MobileSDK application to send custom commands to a PayloadSDK application. This feature would allow for the build of a user interface on a MobileSDK app with a button that can trigger the "checking to land" logic remotely, making the system more interactive and user controlled.'}),"\n",(0,t.jsx)(n.h4,{id:"following-the-landing-target",children:"Following the landing target"}),"\n",(0,t.jsxs)(n.p,{children:["Another enhancement could involve implementing a logic for following a landing target. This feature isn't covered in detail due to the variety of approaches available. A dedicated camera sensor could be used, or the existing video stream from the ",(0,t.jsx)(n.a,{href:"https://developer.dji.com/doc/payload-sdk-tutorial/en/function-set/advanced-function/camera-video-stream-transmission.html",children:"PayloadSDK"})," can be used."]}),"\n",(0,t.jsx)(n.p,{children:'The "follow the target" logic could be triggered using the same mechanism discussed earlier, with a command from the ground application.'}),"\n",(0,t.jsx)(n.p,{children:'This step would refine the approach and lead naturally into the "check to land" logic when the conditions are right.'}),"\n",(0,t.jsx)(n.h4,{id:"landing-risk-validation",children:"Landing risk validation"}),"\n",(0,t.jsx)(n.p,{children:"The current implementation assumes that it is safe to commit to a landing when the sensor detects a plane at approximately 15\xb0. This is a broad assumption and may not be ideal in many practical scenarios. A more nuanced plane validation process should be implemented depending on the specific characteristics of the platform being landing on."}),"\n",(0,t.jsx)(n.p,{children:"Landing on a stable ground vehicle on a road requires different conditions than landing on a moving sea vessel, where stability can vary significantly with weather and sea conditions. Implementing specific parameters for different environments (e.g., smooth surfaces for road vehicles versus dynamic conditions for ships) can make the landing sequence more reliable and tailored to specific use cases."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);